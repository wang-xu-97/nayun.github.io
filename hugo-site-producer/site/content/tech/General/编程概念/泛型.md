---
title: "泛型"
date: 2025-08-06T10:31:06+08:00
draft: false
tags: ["编程思想", "AIGC", "泛型"]
toc: true
showTableOfContents: true
---

泛型（Generics）是编程语言中一种允许在定义函数、数据结构或类时**使用类型参数**的特性。通过泛型，开发者可以编写更通用、灵活的代码，而无需为每种具体类型重复实现相同的逻辑。

## 1. **泛型的核心概念**
### （1）类型参数（Type Parameters）
在定义函数或结构体时，可以声明一个或多个**类型参数**，用方括号 `[]` 包裹（Go 语言风格，其他语言可能用 `<>`）。  
例如：
```go
// T 是类型参数，可以是任何类型
func identity[T any](value T) T {
    return value
}
```

### （2）类型约束（Type Constraints）
限制类型参数的范围，例如要求类型必须支持某些操作（如比较大小、相加等）。  
- Go 中通过接口定义约束：
  ```go
  type Number interface {
      int | float64 // 约束 T 只能是 int 或 float64
  }

  func add[T Number](a, b T) T {
      return a + b
  }
  ```
- 其他语言（如 Java）通过泛型边界（`<T extends Comparable>`）实现类似功能。

### （3）泛型数据结构
泛型不仅用于函数，还可用于定义通用的数据结构（如链表、队列等）。  
例如，Go 中的泛型切片：
```go
type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}
```

## 2. **不同语言中的泛型实现**
| 语言      | 语法示例                          | 特点                               |
|-----------|-----------------------------------|-----------------------------------|
| **Go**    | `func max[T comparable](a, b T)`  | 1.18 引入，基于类型参数和约束。     |
| **Java**  | `<T extends Comparable<T>>`       | 使用类型擦除（运行时无类型信息）。   |
| **C++**   | `template <typename T>`           | 编译时模板展开，功能强大但复杂。     |
| **Rust**  | `fn max<T: Ord>(a: T, b: T) -> T` | 结合 trait 约束，零成本抽象。       |
| **python**  | `type Point[T] = ...` | [3.12泛型特性](/nayun.github.io/tech/coding/python/概念基础/3.12泛型特性)       |

---

## 5. **泛型的优缺点**
### 优点：
1. **代码复用**：避免为不同类型重复编写逻辑。
2. **类型安全**：编译时检查类型错误（比 `interface{}` 更安全）。
3. **性能优化**：编译时生成具体类型的代码（如 C++ 模板）。

### 缺点：
1. **复杂性**：语法和概念可能增加学习成本。
2. **编译时间**：某些语言（如 C++）的泛型可能导致编译时间变长。

---

## 6. **实际应用场景**
1. **通用容器**：如列表、栈、字典等。
2. **工具函数**：如排序、比较、数学运算。
3. **设计模式**：如工厂模式、策略模式等。

---

### 总结
泛型的本质是**将类型作为参数**传递，使代码既能保持通用性，又不牺牲类型安全和性能。它是现代静态类型语言（如 Go、Rust、Swift）的重要特性，能够显著提升代码的抽象能力和可维护性。