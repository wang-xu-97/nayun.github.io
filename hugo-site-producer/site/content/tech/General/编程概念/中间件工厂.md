---
title: "中间件工厂"
date: 2025-08-05T17:02:12+08:00
draft: false
tags: ["技", '编程思想', 'python', 'golang', 'learning']
toc: true
showTableOfContents: true
---

# 概念
在函数式编程和软件架构中，**中间件工厂**是一种创建中间件的高阶函数模式。它是在**函数工厂**（能够生成其他函数的函数）概念基础上的扩展应用。

## 定义

中间件工厂是一个函数，它接收配置参数并返回一个中间件函数。这种模式常见于Web框架（如Express、Koa）和数据处理流程中。

```javascript
// 中间件工厂示例
function createMiddleware(config) {
  return function middleware(req, res, next) {
    // 使用config和实现中间件逻辑
    if (config.condition) {
      // 做一些事情
    }
    next();
  };
}

// 使用
const myMiddleware = createMiddleware({ condition: true });
app.use(myMiddleware);
```

## 核心意义

### 1. 配置与复用性

中间件工厂通过参数化配置，使得单个中间件实现可以适应多种使用场景，大大提高了代码的复用性。

### 2. 封装与隔离

将中间件的创建逻辑封装在工厂函数中，实现了：
- 内部实现的隐藏
- 依赖管理的集中化
- 副作用隔离

### 3. 动态行为定制

允许在运行时根据不同的配置生成具有不同行为的中间件实例。

## 典型场景

1. **认证中间件**：根据不同策略（JWT、OAuth等）生成认证中间件
2. **日志中间件**：根据日志级别、输出目标等配置生成日志中间件
3. **缓存中间件**：根据缓存策略、过期时间等生成缓存处理中间件
4. **错误处理中间件**：根据不同环境（开发/生产）生成错误处理逻辑

## 高级模式

### 组合式中间件工厂

```javascript
function composeMiddlewares(...middlewareFactories) {
  return (config) => {
    const middlewares = middlewareFactories.map(factory => factory(config));
    return (req, res, next) => {
      // 组合中间件的执行逻辑
    };
  };
}
```

### 条件式中间件工厂

```javascript
function conditionalMiddleware(condition, trueMiddleware, falseMiddleware) {
  return (req, res, next) => {
    const middleware = condition(req) ? trueMiddleware : falseMiddleware;
    return middleware(req, res, next);
  };
}
```

## 设计考量

1. **单一职责**：每个中间件工厂应专注于一个明确的功能
2. **无状态设计**：尽可能设计无状态的中间件，状态应通过配置传入
3. **明确的接口**：定义清晰的配置参数和返回的中间件接口
4. **可测试性**：确保中间件工厂和生成的中间件都易于单元测试

中间件工厂模式通过将创建逻辑与执行逻辑分离，为复杂应用提供了更灵活、更可维护的架构解决方案。

# 示例
## Python 示例

### 1. Flask 中间件工厂

```python
from flask import Flask, request

app = Flask(__name__)

def create_logging_middleware(log_level='INFO'):
    def logging_middleware(next_middleware):
        def wrapper(*args, **kwargs):
            if log_level == 'DEBUG':
                print(f"Request: {request.method} {request.path}")
            response = next_middleware(*args, **kwargs)
            if log_level == 'DEBUG':
                print(f"Response: {response.status_code}")
            return response
        return wrapper
    return logging_middleware

# 使用中间件工厂
debug_logging = create_logging_middleware(log_level='DEBUG')
app.before_request(debug_logging)

@app.route('/')
def home():
    return "Hello, World!"

if __name__ == '__main__':
    app.run()
```

### 2. 通用 Python 中间件工厂

```python
def create_auth_middleware(required_role):
    def auth_middleware(request_handler):
        def wrapper(request):
            if request.get('user_role') != required_role:
                return {'error': 'Unauthorized'}, 403
            return request_handler(request)
        return wrapper
    return auth_middleware

# 使用
admin_auth = create_auth_middleware(required_role='admin')

@admin_auth
def handle_admin_request(request):
    return {'data': 'Admin resource'}

# 测试
print(handle_admin_request({'user_role': 'admin'}))  # 正常
print(handle_admin_request({'user_role': 'user'}))   # 返回403错误
```

## Go 示例

### 1. HTTP 中间件工厂

```go
package main

import (
	"fmt"
	"net/http"
)

// 中间件工厂：创建日志中间件
func loggingMiddlewareFactory(logLevel string) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			if logLevel == "DEBUG" {
				fmt.Printf("Request: %s %s\n", r.Method, r.URL.Path)
			}
			next.ServeHTTP(w, r)
		})
	}
}

func mainHandler(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("Hello, World!"))
}

func main() {
	// 使用中间件工厂
	debugLogging := loggingMiddlewareFactory("DEBUG")
	
	mux := http.NewServeMux()
	mux.Handle("/", debugLogging(http.HandlerFunc(mainHandler)))
	
	http.ListenAndServe(":8080", mux)
}
```

### 2. 认证中间件工厂

```go
package main

import (
	"net/http"
)

// 中间件工厂：创建认证中间件
func authMiddlewareFactory(requiredRole string) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			userRole := r.Header.Get("X-User-Role")
			if userRole != requiredRole {
				w.WriteHeader(http.StatusForbidden)
				w.Write([]byte("Forbidden"))
				return
			}
			next.ServeHTTP(w, r)
		})
	}
}

func adminHandler(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("Admin Area"))
}

func main() {
	adminAuth := authMiddlewareFactory("admin")
	
	mux := http.NewServeMux()
	mux.Handle("/admin", adminAuth(http.HandlerFunc(adminHandler)))
	
	http.ListenAndServe(":8080", mux)
}
```

### 3. Go 中间件链工厂

```go
package main

import (
	"net/http"
)

// 中间件链工厂
func middlewareChainFactory(middlewares ...func(http.Handler) http.Handler) func(http.Handler) http.Handler {
	return func(final http.Handler) http.Handler {
		for i := len(middlewares) - 1; i >= 0; i-- {
			final = middlewares[i](final)
		}
		return final
	}
}

func main() {
	logging := loggingMiddlewareFactory("INFO")
	auth := authMiddlewareFactory("user")
	
	// 创建中间件链
	chain := middlewareChainFactory(logging, auth)
	
	mux := http.NewServeMux()
	mux.Handle("/", chain(http.HandlerFunc(mainHandler)))
	
	http.ListenAndServe(":8080", mux)
}
```

这些示例展示了如何在 Python 和 Go 中实现中间件工厂模式，包括日志记录、认证等常见用例。中间件工厂模式使得中间件的创建更加灵活和可配置，同时保持了代码的整洁和可维护性。