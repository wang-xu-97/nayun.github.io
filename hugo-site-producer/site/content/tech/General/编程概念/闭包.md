---
title: "闭包"
date: 2025-07-14T11:35:25+08:00
draft: false
tags: ["技", '编程思想', '闭包', 'python', 'golang']
categories: ["tech"]
toc: true
showTableOfContents: true
---


在创建时封装当时状态，并使当时的状态生存周期延长至与闭包生存周期一致
闭包思想产物：
    1. python装饰器
    2. 回调函数
    3. 函数工厂
    4. 惰性求值
    ...

# 典型用法
## 1. python装饰器
```python
def execute(f):
    f()

@execute
def execute_when_defined():
    print('executed')

```
## 2. 函数工厂
1. 保存调用函数工厂时的参数
2. 调用生成的函数时，使用函数工厂创建函数时的参数上下文
### 示例
1. python api函数工厂
```python
def get_table_grids_wp(cli:Client, docid):
    def func(tableid):
        return [c['children'][0] for c in cli.fetchblocks(docid, tableid)['data']['items']]
    return func

get_table_grids = get_table_grids_wp(cli, docid)
get_table_grids(tid)
```
2. go 基础函数工厂
```go
package main

import "fmt"

// 函数工厂：返回一个加法函数
func makeAdder(addend int) func(int) int {
    return func(x int) int {
        return x + addend
    }
}

func main() {
    add5 := makeAdder(5)  // 创建一个加5的函数
    add10 := makeAdder(10) // 创建一个加10的函数
    
    fmt.Println(add5(3))   // 输出: 8 (3 + 5)
    fmt.Println(add10(3))  // 输出: 13 (3 + 10)
}
```
3. [go 中间件工厂](/nayun.github.io/tech/general/编程概念/中间件工厂)
4. 带配置的函数工厂
```go
package main

import "fmt"

type GreeterConfig struct {
    Prefix string
    Suffix string
}

// 创建问候函数
func NewGreeter(config GreeterConfig) func(string) string {
    return func(name string) string {
        return fmt.Sprintf("%s, %s%s", config.Prefix, name, config.Suffix)
    }
}

func main() {
    friendlyGreeter := NewGreeter(GreeterConfig{
        Prefix: "Hello",
        Suffix: "! Welcome!",
    })
    
    formalGreeter := NewGreeter(GreeterConfig{
        Prefix: "Dear",
        Suffix: ", we are pleased to meet you",
    })
    
    fmt.Println(friendlyGreeter("Alice")) // 输出: Hello, Alice! Welcome!
    fmt.Println(formalGreeter("Bob"))    // 输出: Dear, Bob, we are pleased to meet you
}
```
5. 缓存函数工厂
```go
package main

import "fmt"

// 创建带缓存的函数
func makeCachedFunc(fn func(int) int) func(int) int {
    cache := make(map[int]int)
    return func(x int) int {
        if result, found := cache[x]; found {
            fmt.Printf("Cache hit for %d\n", x)
            return result
        }
        result := fn(x)
        cache[x] = result
        fmt.Printf("Calculated for %d\n", x)
        return result
    }
}

func expensiveCalculation(x int) int {
    // 模拟耗时计算
    return x * x
}

func main() {
    cachedCalc := makeCachedFunc(expensiveCalculation)
    
    fmt.Println(cachedCalc(5)) // 输出: Calculated for 5 \n 25
    fmt.Println(cachedCalc(5)) // 输出: Cache hit for 5 \n 25
}
```