---
title: "Linux文件读写"
date: 2025-07-29T15:19:16+08:00
draft: false
tags: ["技", "基础功能", "linux"]
toc: true
showTableOfContents: true
---
## 核心思想
一切皆文件（Everything is a File），提供了一套统一的接口 (open(), read(), write(), close(), ioctl() 等系统调用) 来操作各种资源，极大地简化了程序设计。

不仅指普通的文本文件、二进制可执行文件、图片、视频等，还包括：

- **硬件设备**： 硬盘 (/dev/sda1)、键盘 (/dev/input)、显示器 (/dev/fb0)、声卡 (/dev/snd)、甚至内存 (/dev/mem) 都被表示为文件。对这些“设备文件”的读写操作实际上是与硬件交互。

- **进程信息**： 正在运行的程序（进程）的信息和控制接口可以通过 /proc 文件系统访问（如 /proc/1234 对应 PID 为 1234 的进程）。

- **系统信息和配置**： /sys 文件系统暴露内核参数、硬件信息和配置选项。

- **网络套接字**： 网络通信的端点。

- **管道**： 进程间通信的通道。

| 特性 | 普通文件 |	管道(Pipe) |	Socket(TCP) |
|---|---|---|---|
|打开方式|	路径直接打开|	pipe()系统调用|	socket()+bind/connect|
|数据存储|	持久化存储	|内存缓冲区	|网络传输|
|访问模式|	随机访问	|顺序访问	|顺序访问|
|生命周期|	显式创建/删除|	进程结束自动销毁	|连接关闭即失效|
|进程通信|	不支持进程间通信|	支持相关进程通信|	支持跨网络通信|
|阻塞行为|	通常非阻塞	|读空阻塞/写满阻塞	|默认阻塞|

## 1. 普通文件
### 代码通用实现
#### 1. python
1. 基本方法：```with open(fp, mode) ```
示例
```python
with open('text.txt', 'w', encoding='utf-8') as f:  # 'w' 覆盖写
    f.write("Hello Python!\n")
    f.writelines(["Line 1\n", "Line 2\n"])  # 写入多行

with open('text.txt', 'r', encoding='utf-8') as f:
    content = f.read()  # 一次性读取
    
with open('text.txt', 'r') as f:
    lines = f.readlines()  # 返回列表

# ========== 二进制文件读写 ==========
data = b'\x48\x65\x6C\x6C\x6F\x21'  # "Hello!" 的二进制
with open('binary.bin', 'wb') as f:  # 'wb' 二进制写
    f.write(data)

with open('binary.bin', 'rb') as f:
    binary_content = f.read()
    print("二进制内容:", binary_content)  # b'Hello!'
    print("解码为字符串:", binary_content.decode('utf-8'))
```
#### 2. c++
1. 基本方法：```fstream```
    1. 读：```std::ifstream```
    1. 写：```std::ofstream```
1. 注：创建流对象后需要手动关闭
1. 示例
```c++
#include <iostream>
#include <fstream>
#include <vector>
#include <string>

int main() {
    // ========== 文本文件读写 ==========
    // 写入文本文件
    std::ofstream textOut("text.txt");
    if (textOut.is_open()) {
        textOut << "Hello C++!\n";
        textOut << "Line 1\nLine 2\n";
        textOut.close();
        std::cout << "文本写入成功" << std::endl;
    } else {
        std::cerr << "文本文件打开失败" << std::endl;
    }

    // 读取文本文件
    std::ifstream textIn("text.txt");
    if (textIn.is_open()) {
        std::string line;
        std::cout << "文本内容:" << std::endl;
        while (std::getline(textIn, line)) {  // 逐行读取
            std::cout << line << std::endl;
        }
        textIn.close();
    } else {
        std::cerr << "文本文件打开失败" << std::endl;
    }

    // ========== 二进制文件读写 ==========
    // 写入二进制文件
    std::ofstream binOut("binary.bin", std::ios::binary);
    char data[] = {0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x21}; // "Hello!"
    if (binOut.is_open()) {
        binOut.write(data, sizeof(data));
        binOut.close();
        std::cout << "二进制写入成功" << std::endl;
    } else {
        std::cerr << "二进制文件打开失败" << std::endl;
    }

    // 读取二进制文件
    std::ifstream binIn("binary.bin", std::ios::binary);
    if (binIn.is_open()) {
        // 获取文件大小
        binIn.seekg(0, std::ios::end);
        size_t size = binIn.tellg();
        binIn.seekg(0, std::ios::beg);

        // 读取到vector
        std::vector<char> buffer(size);
        binIn.read(buffer.data(), size);
        binIn.close();

        std::cout << "二进制内容: ";
        for (char c : buffer) std::cout << c; // 输出 "Hello!"
        std::cout << std::endl;
    } else {
        std::cerr << "二进制文件打开失败" << std::endl;
    }

    return 0;
}
```
#### 3. golang
1. 基本方法：```os```
    1. 读：
        1. 整体读取：```os.ReadFile```
        1. 逐行读取：
            1. ```os.Open```
            2. ```bufio.NewScanner```
    1. 写：```os.WriteFile```
```golang
package main

import (
	"fmt"
	"io"
	"os"
    "bufio"
)

func main() {
	textContent := "Hello Go!\nLine 1\nLine 2\n"
	err := os.WriteFile("text.txt", []byte(textContent), 0644) // 覆盖写入
	if err != nil {
		fmt.Println("文本写入失败:", err)
	} else {
		fmt.Println("文本写入成功")
	}

	data, err := os.ReadFile("text.txt") // 一次性读取
	if err != nil {
		fmt.Println("文本读取失败:", err)
	} else {
		fmt.Println("文本内容:\n", string(data))
	}

	// 逐行读取（使用 bufio）
	file, err := os.Open("text.txt")
	if err != nil {
		fmt.Println("文件打开失败:", err)
		return
	}
	defer file.Close()

	fmt.Println("逐行读取:")
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		fmt.Println(scanner.Text()) // 输出每一行
	}

	// ========== 二进制文件读写 ==========
	binaryData := []byte{0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x21} // "Hello!"
	err = os.WriteFile("binary.bin", binaryData, 0644)
	if err != nil {
		fmt.Println("二进制写入失败:", err)
	} else {
		fmt.Println("二进制写入成功")
	}

	binContent, err := os.ReadFile("binary.bin")
	if err != nil {
		fmt.Println("二进制读取失败:", err)
	} else {
		fmt.Println("二进制内容:", binContent)      // [72 101 108 108 111 33]
		fmt.Println("解码为字符串:", string(binContent)) // "Hello!"
	}

	// 大文件分块读取
	largeFile, err := os.Open("largefile.bin")
	if err != nil {
		fmt.Println("大文件打开失败:", err)
		return
	}
	defer largeFile.Close()

	buffer := make([]byte, 1024) // 1KB缓冲区
	for {
		n, err := largeFile.Read(buffer)
		if err == io.EOF {
			break // 文件结束
		}
		if err != nil {
			fmt.Println("读取错误:", err)
			break
		}
		fmt.Printf("读取 %d 字节\n", n)
		// 处理 buffer[:n]
	}
}
```
## 2. 管道
### 代码实现
#### 1. python
```python
import os
r, w = os.pipe()
pid = os.fork()
if pid == 0:  # Child
    os.close(w)
    data = os.read(r, 100)
    print("Pipe read:", data.decode())
    os._exit(0)
else:  # Parent
    os.close(r)
    os.write(w, b"Pipe message")
    os.wait()
```
#### 2. c++
```c++
#include <iostream>
#include <fstream>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>

int main() {
    int fd[2]; pipe(fd);
    if (fork() == 0) {  // Child
        close(fd[1]); 
        char buf[100];
        read(fd[0], buf, sizeof(buf));
        std::cout << "Pipe read: " << buf << std::endl;
        exit(0);
    } else {  // Parent
        close(fd[0]);
        write(fd[1], "Pipe message", 13);
        wait(nullptr);
    }
}
```
#### 3. golang
```golang
package main

import (
	"fmt"
	"io"
	"net"
)
func main() {

	r, w, _ := os.Pipe()
	go func() {
		w.Write([]byte("Pipe message"))
		w.Close()
	}()
	pipeData, _ := io.ReadAll(r)
	fmt.Println("Pipe read:", string(pipeData))
}
```

## 3. 网络套接字socket
### 代码实现
#### 1.python
```python

import socket
# Server
srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
srv.bind(('127.0.0.1', 12345))
srv.listen(1)
# Client
cli = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
cli.connect(('127.0.0.1', 12345))
# Accept and send
conn, _ = srv.accept()
conn.send(b"Socket data")
print("Socket read:", cli.recv(100).decode())
cli.close(); srv.close()
```
#### 2. c++
```c++
#include <iostream>
#include <fstream>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>

int main() {
    // Server setup
    int srv_fd = socket(AF_INET, SOCK_STREAM, 0);
    sockaddr_in addr = {AF_INET, htons(12345), INADDR_ANY};
    bind(srv_fd, (sockaddr*)&addr, sizeof(addr));
    listen(srv_fd, 1);
    // Client connect
    int cli_fd = socket(AF_INET, SOCK_STREAM, 0);
    connect(cli_fd, (sockaddr*)&addr, sizeof(addr));
    // Communication
    int conn_fd = accept(srv_fd, nullptr, nullptr);
    send(conn_fd, "Socket data", 12, 0);
    char buffer[100];
    recv(cli_fd, buffer, sizeof(buffer), 0);
    std::cout << "Socket read: " << buffer << std::endl;
    close(cli_fd); close(srv_fd);
}
```
#### 3. golang
```golang
package main

import (
	"fmt"
	"io"
	"net"
)
func main() {
	// Server
	listener, _ := net.Listen("tcp", "127.0.0.1:12345")
	go func() {
		conn, _ := listener.Accept()
		conn.Write([]byte("Socket data"))
		conn.Close()
	}()
	// Client
	conn, _ := net.Dial("tcp", "127.0.0.1:12345")
	sockData, _ := io.ReadAll(conn)
	fmt.Println("Socket read:", string(sockData))
}
```
