---
title: "异常处理"
date: 2025-07-29T15:24:57+08:00
draft: false
tags: ["技", "基础功能"]
toc: true
showTableOfContents: true
---

# 核心思想：按需捕获
| 场景 | 处理方式 | 示例 |
| --- | --- | --- |
| 不接受异常，基本不可能异常 | 抛出 | 不做处理，自然抛出 |
| 不接受异常，但有可能异常 | 抛出 | 1. assert condition, reason<br>2. catch后自定义raise |
| 接受异常 | 捕获 | 正常捕获<br>选择日志输出 |


# 代码示例
## 异常重试
需求：执行特定流程抛出异常时，执行指定次数重试
思路：retry变量控制
基本写法：
```python
def process_wp(retry=3):
    e = None
    res = None
    while retry:
        try:
            res = might_err_process()
        except:
            print(f'retry {retry}...')
            e = traceback.format_exc()
            retry -= 1
            # 按需等待
            time.sleep(0.1)
    else:
        raise Exception(str(e))
    return res
```
todo：python可写成装饰器
## 通用场景
### python
处理其他非Exception类的异常时（如键盘中断）可以使用`traceback`模块输出调用栈
```python
import traceback
try:
    # 可能抛出异常的代码
    result = 10 / 0  # 触发 ZeroDivisionError
    with open("missing_file.txt") as f:  # 触发 FileNotFoundError
        print(f.read())
except ZeroDivisionError:
    print("除零错误！")
except FileNotFoundError as e:
    print(f"文件未找到: {e}")
except Exception as e:  # 捕获其他继承自Exception类的异常
    print(f"未知错误: {e}")
except:                 # 捕获其他非Exception类的异常，如键盘中断，可以使用trackback模块输出调用栈
    print(traceback.format_exc())
else:
    print("无异常时执行")
finally:
    print("始终执行的清理代码")

# 输出:
# 除零错误！
# 始终执行的清理代码
```
### c++
```c++
#include <iostream>
#include <stdexcept>
using namespace std;

int main() {
    try {
        // 可能抛出异常的代码
        int denominator = 0;
        if (denominator == 0) {
            throw runtime_error("除零错误！");  // 抛出异常
        }
        int result = 10 / denominator;
    } 
    catch (const runtime_error& e) {  // 捕获特定异常
        cerr << "运行时错误: " << e.what() << endl;
    }
    catch (const exception& e) {  // 捕获所有标准异常
        cerr << "标准异常: " << e.what() << endl;
    }
    catch (...) {  // 捕获所有其他异常
        cerr << "未知异常！" << endl;
    }
    return 0;
}

// 输出:
// 运行时错误: 除零错误！
```
### golang
1. panic/recover类似异常捕获
选择使用runtime包输出调用栈
```golang
package main

import (
	"fmt"
	"runtime/debug"
)

func main() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Println("捕获到 panic:", r)
			fmt.Println("调用栈:")
			fmt.Println(string(debug.Stack()))
		}
	}()

	panic("测试 panic")
}
```
1. 自定义错误值、手动处理
```golang
package main

import (
    "errors"
    "fmt"
)

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("除零错误")
    }
    return a / b, nil
}

func main() {
    // 正常错误处理
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("错误:", err) // 错误: 除零错误
    } else {
        fmt.Println("结果:", result)
    }
}
```