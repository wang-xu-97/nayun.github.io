---
title: "脚本日志"
date: 2025-07-30T14:10:07+08:00
draft: false
tags: ["技", "code", "python", "日志", "基础功能"]
toc: true
showTableOfContents: true
---

# print
## 纯print输出
通过sys.stdout/sys.stderr重定向输出至文件
```python
import sys
class Tee:
    """同时重定向 stdout 和 stderr 到文件和终端"""
    def __init__(self, filename):
        self.file = open(filename, 'a')  # 追加模式
        self.stdout = sys.stdout
        self.stderr = sys.stderr

    def write(self, message):
        self.file.write(message)
        self.stdout.write(message)  # 标准输出到终端
        self.file.flush()          # 确保实时写入文件

    def flush(self):
        self.file.flush()

# 脚本日志重定向
sys.stdout = Tee(f"{__file__.split('.')[0]}.log")
sys.stderr = Tee(f"{__file__.split('.')[0]}.log")


```
## 封装print，自定义输出
```python
from datetime import datetime
class Logger:
    def now(self):return datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")
    def info(self, msg):print(self.now() + ' - INFO - ' + msg)
    def warning(self, msg):print(self.now() + ' - WARN - ' + msg)
    def error(self, msg):print(self.now() + ' - ERROR - ' + msg)

logger = Logger()
```

# logging
## 通用代码
```python
import logging
import os
from datetime import datetime

def setup_logger(name, log_level=logging.INFO, log_file_path=None):
    logger = logging.getLogger(name)
    logger.setLevel(log_level)
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)
    
    if log_file_path is None:
        return logger

    file_handler = logging.FileHandler(log_file_path)
        
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)
    return logger
```
## 默认logger再封装
不设置formatter，自定义logging的info/debug/error方法
实现：
1. info/debug日志分离
2. 日志格式自定义
    1. 日期时间格式精确到.3f
    2. 增加marker功能
    3. 日志输出代码行准确指向前一个调用栈（调用封装日志模块的代码行）
3. 自定义error日志上报、处理
4. 日志锁（增加性能开销，低性能场景适用）
```python
import logging
import os, inspect
from os.path import join
from datetime import datetime
def get_logger(log_root, infolog="info.log", debuglog="debug.log"):
    if not os.path.exists(log_root):os.makedirs(log_root)
    debuglogpath = join(log_root, debuglog)
    infologpath = join(log_root, infolog)
    list(map(lambda p:(os.remove(p) if os.path.exists(p) else None), [debuglogpath, infologpath]))
    logger = logging.getLogger('my_logger')
    logger.setLevel(logging.DEBUG)

    # debug文件日志
    debug_file_handler = logging.FileHandler(debuglogpath)
    debug_file_handler.setLevel(logging.DEBUG)
    logger.addHandler(debug_file_handler)

    # info文件日志
    info_file_handler = logging.FileHandler(infologpath)
    info_file_handler.setLevel(logging.INFO)
    logger.addHandler(info_file_handler)

    # info终端日志
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    logger.addHandler(console_handler)

    return logger

class Logger:
    def __init__(self):
        self.logger = None
        self.lock = threading.Lock()
        self.marklength = 110
        self.error_msg = []

    def init_logger(self, infolog, debuglog, logroot):
        self.logger = get_logger(logroot, infolog, debuglog)

    def padding_size(self, msg):
        return self.marklength - sum(map(lambda c:2 if ord(c) > 255 else 1, msg))

    def now(self):
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]

    def debug(self, msg:str, frame=None):
        frame = inspect.currentframe().f_back if not frame else frame
        f = (frame.f_code.co_filename).split(os.sep)[-1].replace(".py", "")
        l = frame.f_lineno
        with self.lock:
            self.logger.debug(self.now() + ' - DEBUG - ' + f'{f}-{l} - ' + str(msg))

    def info(self, msg:str, frame=None, mark=None):
        frame = inspect.currentframe().f_back if not frame else frame
        f = (frame.f_code.co_filename).split(os.sep)[-1].replace(".py", "")
        l = frame.f_lineno
        markstr = ((self.padding_size(str(msg)) - len(f'{f}{l}')) * "-" + f"[{mark}]") if mark else ""
        with self.lock:
            self.logger.info(self.now() + ' - INFO - ' + f'{f}-{l} - ' + str(msg) + markstr)

    def warning(self, msg:str, frame=None, mark=None):
        frame = inspect.currentframe().f_back if not frame else frame
        f = (frame.f_code.co_filename).split(os.sep)[-1].replace(".py", "")
        l = frame.f_lineno
        markstr = ((self.padding_size(str(msg)) - len(f'{f}{l}')) * "-" + f"[{mark}]") if mark else ""
        with self.lock:
            self.logger.warning(self.now() + ' - WARN - ' + f'{f}-{l} - ' + str(msg) + markstr)

    def error(self, msg:str, frame=None, mark=None, report_msg=True):
        frame = inspect.currentframe().f_back if not frame else frame
        f = (frame.f_code.co_filename).split(os.sep)[-1].replace(".py", "")
        l = frame.f_lineno
        markstr = ((self.padding_size(str(msg)) - len(f'{f}{l}') - 1) * "-" + f"[{mark}]") if mark else ""
        with self.lock:
            self.logger.error(self.now() + ' - ERROR - ' + f'{f}-{l} - ' + str(msg) + markstr)
            if report_msg:
                self.error_msg.append(str(msg))
```
# 自定义logger类，实现logger实例解耦
使用自定义初始化函数init_logger，可以实现不同python文件使用不同logger实例
1. 使用logging对象
```python
class Logger:
    def init_logger(self, logger):
        self.logger = logger

logger.init_logger(get_logger(logroot, infolog, debuglog))
```
2. 使用print封装
```python
from datetime import datetime
class Wrapprint:
    def now(self):return datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")
    def info(self, msg):print(self.now() + ' - INFO - ' + msg)
    def warning(self, msg):print(self.now() + ' - WARN - ' + msg)
    def error(self, msg):print(self.now() + ' - ERROR - ' + msg)

class Logger:
    def init_logger(self, logger):
        self.logger = logger

logger.init_logger(Wrapprint())
```

## todo: 使用类继承实现logger多态